【游戏核心逻辑】

1. **布局规则**
   - 奇数行泡泡数量比偶数行多一列
   - 行与行之间采用交错排列方式

2. **位置计算**
   - 行间距 = 泡泡直径 × cos(30°)
   - x坐标计算：
     - 奇数行：x = 起点x + 列号 × 泡泡直径
     - 偶数行：x = 起点x + 泡泡直径/2 + 列号 × 泡泡直径
   - y坐标：y = 起点y + 行号 × 行间距

3. **泡泡生成**
   - 使用双重循环（行循环+列循环）克隆泡泡
   - 偶数行创建的泡泡数量 = 列数 - 1

4. **行列号存储**
   - 每个泡泡克隆时记录自己的行号和列号

【交互细节】

1. **点击响应机制**
   - 点击事件触发背景上的坐标转换逻辑
   - 根据点击位置(x,y)逆向推导出行号和列号

2. **逆向推导公式**
   - 行号 = round((y - 起点y) / 行间距)
   - 列号计算：
     - 奇数行：列号 = round((x - 起点x) / 泡泡直径)
     - 偶数行：列号 = round((x - 起点x - 泡泡直径/2) / 泡泡直径)

3. **泡泡反馈**
   - 计算出行列号后向所有泡泡广播通知
   - 匹配行列号的泡泡执行"弹出"动画

4. **坐标验证**
   - 使用四舍五入确保坐标位于泡泡区域内
【消除机制】

1. **连锁消除**
   - 当满足条件泡泡消除后，检测悬空泡泡
   - 悬空判定：上方连接路径中断（存在0值位置）
   - 连锁消除执行：自动清除所有悬空泡泡

2. **消除条件**
   - 基础条件：同色相邻泡泡 ≥ 3
   - 连锁条件：连接路径中断的独立泡泡群组
   - 仅当点击位置在泡泡范围内才触发响应
【查找算法实现】

1. **停靠点查找**
   - 起点：新停靠的泡泡
   - 目标：相邻的同色泡泡
   - 递归条件：颜色完全匹配
   - 结束条件：无更多相邻同色泡泡

2. **连锁查找**
   - 起点：第一行每个泡泡（顺序遍历）
   - 目标：所有连通非零泡泡
   - 递归条件：相邻泡泡数值 ≠ 0
   - 结束条件：遍历完第一行所有泡泡

3. **递归查找核心逻辑**
   ```pseudocode
   function findConnectedBubbles(start, condition):
     标记 start 为已访问
     遍历 start 的六个方向相邻位置:
         if 该位置有效 and 未访问 and 满足 condition:
            findConnectedBubbles(相邻位置, condition)
   ```

4. **数据结构抽象**
   - 泡泡颜色 → 数字编码（1=红, 2=蓝,...）
   - 空位置 → 0
   - 泡泡矩阵：二维数组存储行列状态